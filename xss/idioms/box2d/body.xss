<xss:parameter id="it"/>
<xss:parameter id="template"/>

<xss:class>
    property world;
    property visual_parent : string;

    method basic_properties()
    {
        //fixture properties
        var density = 1.0;
        if (it.density)
            density = it.density;
        else if (template)
            density = template.density;
         
        var friction = 0.5;
        if (it.friction)
            friction = it.friction;
        else if (template)
            density = template.friction;

        var restitution = 0.2; 
        if (it.restitution)
            restitution = it.restitution;
        else if (template)
            density = template.restitution;

        //body type
        var body_type = "";
        if (!it.body_type)
            compiler.error("Physics object must have a body type");

        if (it.body_type == "static")
            body_type = "b2Body.b2_staticBody";
        else if (it.body_type == "kinematic")
            body_type = "b2Body.b2_kinematicBody";
        else if (it.body_type == "dynamic")
            body_type = "b2Body.b2_dynamicBody";
        else
            compiler.error("Invalid body_type", object = it.id, body_type = it.body_type);

        //output it all
        out()
        {
             fixDef.density = <xss:e v="density"/>;
             fixDef.friction = <xss:e v="friction"/>;
             fixDef.restitution = <xss:e v="restitution"/>;
             bodyDef.type = <xss:e v="body_type"/>;
        }
    }

    method shape()
    {
        if (!it.shape)
            compiler.error("Invalid bodies must have a shape", object = it.id);

        if (it.shape == "rect")
        {
            out()
            {
                fixDef.shape = new b2PolygonShape;
            }

            if (visual_parent)
            {
                out()
                {
                    fixDef.shape.SetAsBox(<xss:e v="visual_parent"/>.w, <xss:e v="visual_parent"/>.h);
                }
            }
            else
            {
                out()
                {
                    fixDef.shape.SetAsBox(<xss:e v="it.width"/>, <xss:e v="it.height"/>);
                }
            }
        }
        else if (it.shape == "circle")
        {
            if (it.radius != null)
            {
                out()
                {
                    fixDef.shape = new b2CircleShape(<xss:e v="it.radius"/>/g_world_scale);
                }
            }
            else if (visual_parent)
            {
                out()
                {
                    fixDef.shape = new b2CircleShape(Math.min(<xss:e v="visual_parent"/>.w, <xss:e v="visual_parent"/>.h)/(2*g_world_scale));
                }
            }
            else
            {
                compiler.error("Circle shapes mush have a radius or visual parent");
            }
        }
        else
            compiler.error("Invalid shape", object = it.id, shape = it.shape);
    }

    method position()
    {
        if (visual_parent)
        {
            out()
            {
                bodyDef.position.Set((<xss:e v="visual_parent"/>.x + <xss:e v="visual_parent"/>.w/2)/g_world_scale,
                                     (<xss:e v="visual_parent"/>.y + <xss:e v="visual_parent"/>.h/2)/g_world_scale);
            }
        }
        else
        {
            var x  = it.x;
            var y  = it.y;

            if (!x) x = 0;
            if (!y) y = 0;

            out()
            {
                bodyDef.position.Set(<xss:e v="x"/>, <xss:e v="y"/>);
            }
        }
    }

    private method foreign_parent(obj)
    {
        var foreing = obj.parent;
        if (foreing)
        {
            if (foreing.has_property("x") &&
                foreing.has_property("y") &&
                foreing.has_property("width") &&
                foreing.has_property("height"))
            {
                return foreing;
            }

        } 
         
        return null;
    }

    on render()
    {
        world  = template;
        var vp = foreign_parent(it);
        
        if (vp)
        {
            if (compiler.is_type(vp))
                visual_parent = "this";
            else
                visual_parent = vp.output_id;
        }
        else 
            visual_parent = null;
            
        compiler.log(visual_parent);

        basic_properties();
        shape();
        position();

        //add the body into the world
        out()
        {
            current_body = g_world.CreateBody(bodyDef);
            current_body.CreateFixture(fixDef);
        }

        if (visual_parent)
        {
            out()
            {
                <xss:e v="visual_parent"/>.physics = current_body;
                <xss:e v="visual_parent"/>.moved = update_body_position;
                
                current_body.host = <xss:e v="visual_parent"/>;
            }
        }
    }

</xss:class>
