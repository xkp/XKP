<xss:parameter id="it"/>
<xss:parameter id="template"/>

<xss:class>
    property world;
    property visual_parent;

    method basic_properties()
    {
        //fixture properties
        var density = template.density;
        if (it.density)
            density = it.density;
         
        var friction = template.friction;
        if (it.friction)
            friction = it.friction;

        var restitution = template.restitution;
        if (it.restitution)
            restitution = it.restitution;

        //body type
        var body_type = "";
        if (!it.body_type)
            compiler.error("Physics object must have a body type");

        if (it.body_type == "static")
            body_type = "b2Body.b2_staticBody";
        else if (it.body_type == "kinematic")
            body_type = "b2Body.b2_kinematicBody";
        else if (it.body_type == "dynamic")
            body_type = "b2Body.b2_dynamicBody";
        else
            compiler.error("Invalid body_type", object = it.id, body_type = it.body_type);

        //output it all
        out()
        {
             fixDef.density = <xss:e v="density"/>;
             fixDef.friction = <xss:e v="friction"/>;
             fixDef.restitution = <xss:e v="restitution"/>;
             bodyDef.type = <xss:e v="body_type"/>;
        }
    }

    method shape()
    {
        if (!it.shape)
            compiler.error("Invalid bodies must have a shape", object = it.id);

        if (it.shape == "rect")
        {
            out()
            {
                fixDef.shape = new b2PolygonShape;
            }

            if (visual_parent)
            {
                out()
                {
                    fixDef.shape.SetAsBox(<xss:e v="visual_parent.output_id"/>.w, <xss:e v="visual_parent.output_id"/>.h);
                }
            }
            else
            {
                out()
                {
                    fixDef.shape.SetAsBox(<xss:e v="it.width"/>, <xss:e v="it.height"/>);
                }
            }
        }
        else if (it.shape == "circle")
        {
            if (visual_parent)
            {
                var id = visual_parent.output_id;
                out()
                {
                    fixDef.shape = new b2CircleShape(Math.min(<xss:e v="id"/>.w, <xss:e v="id"/>.h)/(2*<xss:e v="world.scale"/>));
                }
            }
            else
            {
                out()
                {
                    fixDef.shape = new b2CircleShape(<xss:e v="it.radius"/>);
                }
            }
        }
        else
            compiler.error("Invalid shape", object = it.id, shape = it.shape);
    }

    method position()
    {
        if (visual_parent)
        {
            var id = visual_parent.output_id;
            out()
            {
                bodyDef.position.Set((<xss:e v="id"/>.x + <xss:e v="id"/>.w/2)/<xss:e v="world.scale"/>, 
                                     (<xss:e v="id"/>.y + <xss:e v="id"/>.h/2)/<xss:e v="world.scale"/>);
            }
        }
        else
            out()
            {
                bodyDef.position.Set(<xss:e v="it.x"/>, <xss:e v="it.y"/>);
            }
    }

    private method foreign_parent(obj)
    {
        var foreing = obj.parent;
        if (foreing)
        {
            if (foreing.has_property("x") &&
                foreing.has_property("y") &&
                foreing.has_property("width") &&
                foreing.has_property("height"))
            {
                return foreing;
            }

        } 
         
        return null;
    }

    on render()
    {
        world  = template;
        visual_parent = foreign_parent(it);

        basic_properties();
        shape();
        position();

        //add the body into the world
        out()
        {
            current_body = g_world.CreateBody(bodyDef);
            current_body.CreateFixture(fixDef);
        }

        if (visual_parent)
        {
            out()
            {
                <xss:e v="visual_parent.output_id"/>.physics = current_body;
                current_body.xs_visual = <xss:e v="visual_parent.output_id"/>;
            }
        }
    }

</xss:class>
