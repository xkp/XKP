<xss:parameter id="clazz"/>
<xss:parameter id="appName"/>
<xss:parameter id="base_namespace"/>
<xss:parameter id="is_type" default="false"/>
<xss:parameter id="main" default="0"/>

package <xss:e value="base_namespace"/>.<xss:e value="appName"/>;

import java.util.ArrayList;
import java.util.Arrays;

import android.view.View;
<xss:code>
	if(is_type)
	{
		out(indent = 0)
		{
			import android.content.Context;
			import android.content.res.TypedArray;
			import android.util.AttributeSet;
			import android.view.LayoutInflater;
		}
	} else
	{
		out(indent = 0)
		{
			import android.app.Activity;
			import android.os.Bundle;
		}
	}
</xss:code>

import <xss:e value="base_namespace"/>.libs.Layout.XKPLayout;
<xss:marker id="imports"/>

<xss:code>
	string class_name = "";
	string cextends = "";
	if(is_type)
	{
		class_name = clazz.output_id;
		if(clazz.super)
			cextends = "extends " + clazz.super.output_id;
	} else
	{
		class_name = "Act" + appName;
		cextends = "extends Activity";
	}
	
	out(indent = 0)
	{
		public class <xss:e value="class_name"/> 
						<xss:e value="cextends"/>
	}
</xss:code>
						<xss:marker id="interfaces"/>

<xss:code>
	//contents
	array<string> interfaces = [];
	array<string> classes	 = [];
	array<string> utils		 = [];
	
	bool class_utils = false;
	
	for(var inst in clazz.instances)
	{
		//TRACE: log
		//compiler.log("View: " + inst.id);

		if(inst.no_script || inst.no_render)
			continue;
		
		if(inst.id && inst.id != application.id)
		{
			out(indent = 1, marker = "declarations")
			{
				private <xss:e value="inst.type.output_id"/> <xss:e value="inst.output_id"/>;
			}
		}
		
		//find all classes without duplicates
		if(inst.classes)
		{
			for(var c in inst.classes)
			{
				bool found3 = false;
				for(var cla in classes)
				{
					if(cla == c.name)
					{
						found3 = true;
						break;
					}
				}
				
				if(!found3)
				{
					//TRACE: log
					//compiler.log("Adding class " + c.name + " on " + clazz.id);
					classes += c.name;
					
					string xss_file = "class.xss/" + c.file_name;
					compiler.xss(xss_file, marker = "defined_class", appName, inst);
				}
			}
		}
		
		if(inst.utils)
		{
			if(!class_utils)
			{
				out(indent = 2, marker = "declarations")
				{
					XKPUtils util = new XKPUtils();
				}
				
				out(indent = 2, marker = "defined_class_util")
				{
					public class XKPUtils <xss:open_brace/>
				}
				
				class_utils = true;
			}
			
			for(var util in inst.utils)
			{
				bool found4 = false;
				for(var utl in utils)
				{
					if(utl == util.name)
					{
						found4 = true;
						break;
					}
				}
				
				if(!found4)
				{
					//TRACE: log
					//compiler.log("Adding method " + util.name +" to XKPUtil static class.");
					utils += util.name;
					
					string util_file = "class.xss/" + util.file_name;
					compiler.xss(util_file, marker = "defined_class_util");
				}
			}
		}
	
		//find necessary events interfaces without duplicates
		bool firstTime = true;
		for(var e in inst.events)
		{
			if(e.interface && e.implemented)
			{
				bool found2 = false;
				for(var it in interfaces)
				{
					if(it == e.interface)
					{
						found2 = true;
						break;
					}
				}
				
				if(!found2)
				{
					//TRACE: log
					//compiler.log("Adding interface " + e.interface + " on " + clazz.id);
					interfaces += e.interface;
					
					if(firstTime)
					{
						out(dont_break = true, indent = 2, marker = "interfaces")
						{
							implements <xss:e value="e.interface"/>
						}
						
						firstTime = false;
					}
					else
					{
						out(dont_break = true, indent = 0, marker = "interfaces")
						{
							, <xss:e value="e.interface"/>;
						}
					}
					
					string ret_type = "void";
					if(e.return_type)
						ret_type = e.return_type;
					
					//TODO: implements call to arguments from classes by event name
					out(indent = 1, marker = "events")
					{
						public <xss:e value="ret_type"/> <xss:e value="e.output_id"/>(<xss:e value="e.def_args"/>) <xss:open_brace/>
							switch (v.getId()) <xss:open_brace/>
					}
					
					for(var insti in clazz.instances)
					{
						for(var e_insti in insti.events)
						{
							if(e_insti.output_id == e.output_id && e_insti.implemented)
							{
								out(indent = 2, marker = "events")
								{
									case R.id.<xss:e value="insti.id"/>:
										<xss:e value="e.output_id"/><xss:e value="insti.id"/>(<xss:e value="e.param_mthd"/>);
										break;
										
								}
							}
						}
					}
					
					out(indent = 1, marker = "events")
					{
						<xss:close_brace/> //switch
					}
					
					if(ret_type == "boolean")
					{
						out(indent = 1, marker = "events")
						{
							return true;
						}
					}
					
					out(indent = 1, marker = "events")
					{
						<xss:close_brace/>
					}
				}
			}
		}
	}
	
	if(class_utils)
	{
		out(indent = 2, marker = "defined_class_util")
		{
			<xss:close_brace/>
		}
	}
</xss:code>

{
	<xss:marker id="declarations"/>
	<xss:e value="'Act' + appName"/> application;
<xss:code>
	// build instance or type constructors
	string prefix = "";
	if(is_type)
	{
		out(indent = 0)
		{
			public <xss:e value="clazz.output_id"/>(Context context) <xss:open_brace/>
				this(context, null);
			<xss:close_brace/>
			
			public <xss:e value="clazz.output_id"/>(Context context, AttributeSet attrs) <xss:open_brace/>
				super(context, attrs);
				
				LayoutInflater li = (LayoutInflater) context.
					getSystemService(Context.LAYOUT_INFLATER_SERVICE);
				
				// link xml file with inflater
				View root = li.inflate(R.layout.<xss:e value="clazz.output_id"/>, this);
				
				// and with all views
		}
		prefix = "root.";
	} else
	{
		out(indent = 0)
		{
			@Override
			public void onCreate(Bundle savedInstanceState) <xss:open_brace/>
				super.onCreate(savedInstanceState);
				setContentView(R.layout.main);
				bindViews();
				initInstances();
                initCallers();
			<xss:close_brace/>
			
			private void bindViews() <xss:open_brace/>
		}
	}

	for(var inst in clazz.instances)
	{
		if(inst.id == null || inst.no_script || inst.no_render)
			continue;
		
		if(inst.id && inst.id != application.id)
		{
			out(indent = 2)
			{
				<xss:e value="inst.output_id"/> = (<xss:e value="inst.type.output_id"/>) <xss:e value="prefix"/>findViewById(R.id.<xss:e value="inst.output_id"/>);
			}
		}
		
		for(var e in inst.events)
		{
			if(e.interface && e.implemented)
			{
				string handler = "set" + e.interface;
				if(e.set_handle)
					handler = e.set_handle;
				
				out(indent = 2)
				{
					<xss:e value="inst.output_id"/>.<xss:e value="handler"/>(<xss:e value="e.set_param_hnd"/>);
				}
			}
		}
		
		var qprops = inst.query_properties("*");
		for(var p in qprops)
		{
			if(p.set_handle)
			{
				out(indent = 2)
				{
					<xss:e value="inst.output_id"/>.<xss:e value="p.set_handle"/>(<xss:e value="p.set_param_hnd"/>);
				}
			}
		}
		
		if(inst.inits)
		{
			for(var init in inst.inits)
			{
				string init_file = "class.xss/" + init.file_name;
				compiler.xss(init_file, it = inst);
			}
		}
	}
	
	if(is_type)
	{
		out(indent = 0)
		{
			TypedArray ta = context.obtainStyledAttributes(
					attrs, R.styleable.<xss:e value="clazz.output_id"/>);
		}
	}
</xss:code>
			<xss:marker id="set_property_value"/>
<xss:code>
	if(is_type)
	{
		out(indent = 0)
		{
			ta.recycle();
		}
	}
</xss:code>
	}

void initCallers() {
	<xss:marker id="callers"/>
}

<xss:code>
	// render instances of other idioms
	if(!is_type)
	{
		compiler.inject("render_initialization", clazz = clazz, bns = base_namespace, app = appName);
		
		out(indent = 0)
		{
			void initInstances() <xss:open_brace/>
				application = this;
		}
		
		compiler.inject("render_instances", app = appName);
	
		out(indent = 0)
		{
			<xss:close_brace/>
		}
    }
	else
	{
		compiler.inject("render_type_initialization", clazz = clazz, bnd = base_namespace, app = appName);
	}
	
	// render other idiom scripts
	compiler.inject("render_idiom_scripts", main = main);
</xss:code>

<xss:marker id="events"/>

<xss:code>
	if(is_type)
	{
		//TRACE: log
		//compiler.log("Custom class " + clazz.output_id + "...");
	} else
	{
		clazz.instances += application;
	}
	
	for(var i in clazz.instances)
	{
		compiler.xss("../java/instance.xss", it = i);
	}
	
	if(is_type)
	{
		compiler.xss("../java/instance.xss", it = clazz);
		
		//TODO: include all this to another xss file with only structure, maybe to 'styleableProperties.xml.xss'
		for(var prop in clazz.properties)
		{
			if(!prop.set || !prop.type)
				continue;
				
			string method_set = prop.output_id + "_set";
			string style_name = "R.styleable." + clazz.output_id + "_" + prop.id;
			string get_function = "";
			string more_params = "";
			
			if(prop.type.id == "string")
			{
				get_function = "getString";
			} else
			if(prop.type.id == "int")
			{
				get_function = "getInteger";
				more_params = ", 0";
			} else
			if(prop.type.id == "bool")
			{
				get_function = "getBoolean";
				more_params = ", false";
			} else
			if(prop.type.id == "float")
			{
				get_function = "getFloat";
				more_params = ", 0.0";
			} else
			{
				get_function = "getResourceId";
				more_params = ", 0";
			}
			
			string func_resrc = "ta." + get_function;
			
			out(marker = "set_property_value")
			{
				<xss:e value="method_set"/>(<xss:e value="func_resrc"/>(<xss:e value="style_name"/><xss:e value="more_params"/>));
			}
		}
		
		string output_filename = appName + "/res/values/" + clazz.id + "Style.xml";
		compiler.xss("styleableProperties.xml.xss", output_file = output_filename, clazz = clazz);
	}
</xss:code>

<xss:marker id="defined_class"/>
<xss:marker id="defined_class_util"/>
}
