<xss:parameter id="clazz"/>
<xss:parameter id="appName"/>
package com.xkp.android.<xss:e value="appName"/>;

import java.util.ArrayList;
import java.util.Arrays;

import android.view.View;
import android.content.Context;
import android.content.res.TypedArray;
import android.util.AttributeSet;
import android.view.LayoutInflater;

<xss:marker id="imports"/>

<xss:code>
	string cextends = "";
	if(clazz.super)
		cextends = "extends " + clazz.super.output_id;
	
	out(indent = 0)
	{
		public class <xss:e value="clazz.output_id"/> 
						<xss:e value="cextends"/>
	}
</xss:code>
						<xss:marker id="interfaces"/>

<xss:code>
	//TODO: try to unify this file with mainActivity.java.xss

	//contents
	array<string> imports    = [];
	array<string> interfaces = [];
	array<string> classes	 = [];
	
	bool class_utils = false;
	
	for(var inst in clazz.instances)
	{
		//TRACE: log
		//compiler.log("View: " + inst.id);

		if(inst.id && inst.id != application.id)
		{
			out(indent = 1, marker = "declarations")
			{
				private <xss:e value="inst.type.output_id"/> <xss:e value="inst.output_id"/>;
			}
		}
		
		//find necessary imports without duplicates
		if(inst.imports && !inst.xkpview)
		{
			//TIPS: live is hard, and very long; :)
			//TODO: it's necessary to implement vector, stack, queue and set containers in vm
			for(var i in inst.imports)
			{
				//TRACE: log
				//compiler.log("Import: " + i.import);
				bool found1 = false;
				for(var imp in imports)
				{
					if(imp == i.import)
					{
						found1 = true;
						break;
					}
				}
				
				if(!found1)
				{
					compiler.log("Adding import " + i.import + " on custom class " + clazz.id);
					imports += i.import;
					
					out(marker = "imports")
					{
						import <xss:e value="i.import"/>;
					}
				}
			}
		}
		
		//find all classes without duplicates
		if(inst.classes)
		{
			for(var c in inst.classes)
			{
				bool found3 = false;
				for(var cla in classes)
				{
					if(cla == c.name)
					{
						found3 = true;
						break;
					}
				}
				
				if(!found3)
				{
					compiler.log("Adding class " + c.name + " on custom class " + clazz.id);
					classes += c.name;
					
					string xss_file = "class.xss/" + c.file_name;
					compiler.xss(xss_file, marker = "defined_class", appName, inst);
				}
			}
		}
		
		if(inst.utils)
		{
			if(!class_utils)
			{
				out(indent = 2, marker = "declarations")
				{
					XKPUtils util = new XKPUtils();
				}
				
				out(indent = 2, marker = "defined_class_util")
				{
					public class XKPUtils <xss:open_brace/>
				}
				
				class_utils = true;
			}
			
			object util = inst.utils;
			string util_file = "class.xss/" + util.file_name;
			compiler.xss(util_file, marker = "defined_class_util");
		}
	
		//find necessary events interfaces without duplicates
		bool firstTime = true;
		for(var e in inst.events)
		{
			if(e.interface && e.implemented)
			{
				bool found2 = false;
				for(var it in interfaces)
				{
					if(it == e.interface)
					{
						found2 = true;
						break;
					}
				}
				
				if(!found2)
				{
					compiler.log("Adding interface " + e.interface + " on custom class " + clazz.id);
					interfaces += e.interface;
					
					if(firstTime)
					{
						out(dont_break = true, indent = 2, marker = "interfaces")
						{
							implements <xss:e value="e.interface"/>
						}
						
						firstTime = false;
					}
					else
					{
						out(dont_break = true, indent = 0, marker = "interfaces")
						{
							, <xss:e value="e.interface"/>;
						}
					}
					
					string ret_type = "void";
					if(e.return_type)
						ret_type = e.return_type;
					
					//TODO: implements call to arguments from classes by event name
					out(indent = 1, marker = "events")
					{
						@Override
						public <xss:e value="ret_type"/> <xss:e value="e.output_id"/>(<xss:e value="e.def_args"/>) <xss:open_brace/>
							switch (v.getId()) <xss:open_brace/>
					}
					
					for(var insti in clazz.instances)
					{
						for(var e_insti in insti.events)
						{
							if(e_insti.output_id == e.output_id && e_insti.implemented)
							{
								out(indent = 2, marker = "events")
								{
									case R.id.<xss:e value="insti.id"/>:
										<xss:e value="e.output_id"/><xss:e value="insti.id"/>(<xss:e value="e.param_mthd"/>);
										break;
										
								}
							}
						}
					}
					
					out(indent = 1, marker = "events")
					{
						<xss:close_brace/> //switch
					}
					
					if(ret_type == "boolean")
					{
						out(indent = 1, marker = "events")
						{
							return true;
						}
					}
					
					out(indent = 1, marker = "events")
					{
						<xss:close_brace/>
					}
				}
			}
		}
	}
	
	if(class_utils)
	{
		out(indent = 2, marker = "defined_class_util")
		{
			<xss:close_brace/>
		}
	}
</xss:code>

{
	<xss:marker id="declarations"/>

	public <xss:e value="clazz.output_id"/>(Context context) {
		this(context, null);
	}
	
	public <xss:e value="clazz.output_id"/>(Context context, AttributeSet attrs) {
		super(context, attrs);
		
		LayoutInflater li = (LayoutInflater) context.
			getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		
		// link xml file with inflater
		View root = li.inflate(R.layout.<xss:e value="clazz.output_id"/>, this);
		
		// and with all views
<xss:code>
	for(var inst in clazz.instances)
	{
		if(inst.id == null)
			continue;
		
		if(inst.id && inst.id != application.id)
		{
			out(indent = 2)
			{
				<xss:e value="inst.output_id"/> = (<xss:e value="inst.type.output_id"/>) root.findViewById(R.id.<xss:e value="inst.output_id"/>);
			}
		}
		
		for(var e in inst.events)
		{
			if(e.interface && e.implemented)
			{
				string handler = "set" + e.interface;
				if(e.set_handle)
					handler = e.set_handle;
				
				out(indent = 2)
				{
					<xss:e value="inst.output_id"/>.<xss:e value="handler"/>(<xss:e value="e.set_param_hnd"/>);
				}
			}
		}
		
		var qprops = inst.query_properties("*");
		for(var p in qprops)
		{
			if(p.set_handle)
			{
				out(indent = 2)
				{
					<xss:e value="inst.output_id"/>.<xss:e value="p.set_handle"/>(<xss:e value="p.set_param_hnd"/>);
				}
			}
		}
		
		if(inst.inits)
		{
			object init = inst.inits;
			string util_file = "class.xss/" + init.file_name;
			compiler.xss(util_file, it = inst);
		}
	}
</xss:code>
		TypedArray ta = context.obtainStyledAttributes(
				attrs, R.styleable.<xss:e value="clazz.output_id"/>);
		
		<xss:marker id="set_property_value"/>
		
		ta.recycle();
	}
	
<xss:marker id="events"/>
<xss:code>
	//TRACE: log
	compiler.log("Custom class " + clazz.output_id + "...");
	for(var i in clazz.instances)
	{
		compiler.xss("../java/instance.xss", it = i);
	}
	
	compiler.xss("../java/instance.xss", it = clazz);
	
	//TODO: include all this to another xss file with only structure, maybe to 'styleableProperties.xml.xss'
	for(var prop in clazz.properties)
	{
		if(!prop.set || !prop.type)
			continue;
			
		string method_set = prop.output_id + "_set";
		string style_name = "R.styleable." + clazz.output_id + "_" + prop.id;
		string get_function = "";
		string more_params = "";
		
		if(prop.type.id == "string")
		{
			get_function = "getString";
		} else
		if(prop.type.id == "int")
		{
			get_function = "getInteger";
			more_params = ", 0";
		} else
		if(prop.type.id == "bool")
		{
			get_function = "getBoolean";
			more_params = ", false";
		} else
		if(prop.type.id == "float")
		{
			get_function = "getFloat";
			more_params = ", 0.0";
		} else
		{
			get_function = "getResourceId";
			more_params = ", 0";
		}
		
		string func_resrc = "ta." + get_function;
		
		out(marker = "set_property_value")
		{
			<xss:e value="method_set"/>(<xss:e value="func_resrc"/>(<xss:e value="style_name"/><xss:e value="more_params"/>));
		}
	}
	
	string output_filename = appName + "/res/values/" + clazz.id + "Style.xml";
	compiler.xss("styleableProperties.xml.xss", output_file = output_filename, clazz = clazz);
</xss:code>

<xss:marker id="defined_class"/>
<xss:marker id="defined_class_util"/>
}
